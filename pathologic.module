<?php
// $Id$

/**
 * @file
 * Pathologic text filter for Drupal.
 *
 * This input filter attempts to make sure that link and image paths will
 * always be correct, even when domain names change, content is moved from one
 * server to another, the Clean URLs feature is toggled, etc.
 */

/**
 * Implementation of hook_filter_info().
 */
function pathologic_filter_info() {
  return array(
    'pathologic' => array(
      'title' => t('Correct URLs with Pathologic'),
      'process callback' => '_pathologic',
      'settings callback' => '_pathologic_settings',
      'default settings' => array(
        'href' => TRUE,
        'src' => TRUE,
        'local_paths' => '',
      ),
/*       'tips callback' => '_pathologic_tips', */
      'weight' => 65535,
    )
  );
}

/**
 * Settings callback for Pathologic.
 */
function _pathologic_settings($form, &$form_state, $filter, $format, $defaults) {
  return array(
    'reminder' => array(
      '#type' => 'item',
      '#title' => t('In most cases, Pathologic should be the <em>last</em> filter in the &ldquo;Filter processing order&rdquo; list.'),
      '#weight' => -10,
    ),
    'href' => array(
      '#type' => 'checkbox',
      '#title' => t('Transform values of <em>href</em> attributes'),
      '#default_value' => isset($filter->settings['href']) ? $filter->settings['href'] : $defaults['href'],
      '#description' => t('<em>href</em> attributes are used in link tags.'),
      '#weight' => 0,
    ),
    'src' => array(
      '#type' => 'checkbox',
      '#title' => t('Transform values of <em>src</em> attributes'),
      '#default_value' => isset($filter->settings['src']) ? $filter->settings['src'] : $defaults['src'],
      '#description' => t('<em>src</em> attributes are used in image tags and tags for other types of embedded media.'),
      '#weight' => 10,
    ),
    'local_paths' => array(
      '#type' => 'textarea',
      '#title' =>  t('Also considered local'),
      '#default_value' => isset($filter->settings['local_paths']) ? $filter->settings['local_paths'] : $defaults['local_paths'],
      '#description' => t('Enter the beginning of paths which should also be considered local for this server. Please read <a href="!docs">Pathologic&rsquo;s documentation</a> for more information about this feature.', array('!docs' => 'http://drupal.org/node/257026')),
      '#weight' => 20,
    ),
  );
}

/**
 * Pathologic filter callback.
 */
function _pathologic($text, $filter) {
  // Which attributes are we going to be looking for?
  if ($filter->settings['href'] && $filter->settings['src']) {
    $attrs = 'href|src';
  }
  elseif ($filter->settings['href']) {
    $attrs = 'href';
  }
  elseif ($filter->settings['src']) {
    $attrs = 'src';
  }
  else {
    // Apparently, we're not configured to work on either HREF or SRC attrs, so…
    return $text;
  }

  // Parse the list of the paths also considered local.
  $paths_text = trim($filter->settings['local_paths']);
  if ($paths_text === '') {
    $paths = array();
  }
  else {
    $paths = array_map('trim', explode("\n", trim($filter->settings['local_paths'])));
  }
  // Add "this" path
  $paths[] = url('<front>', array('absolute' => TRUE));
  // Remove duplicates, since it's possible "this" path was already in the list
  $paths = array_unique($paths);

  // We need to account for the fact that
  // http://example.com/foo
  // http://example.com/?q=foo
  // http://example.com/index.php?q=foo
  // …are all valid.

  $pattern = '~(' . $attrs . ')="(((internal:|' . implode('|', $paths) . ')(/?(index.php)?(\?q=)?)|(?!(/|mailto:|.*:/))(\?q=)?)([^"]*))~';
  // $regex looks like:
  // ~(href|src)="(((http://example.com|http://example.org)(/?(index.php)?(\?q=)?)|(?!(/|mailto:|.*:/))(internal:|\?q=)?)([^"]*))~
  $text = preg_replace_callback($pattern, '_pathologic_replace', $text);
  return $text;
}

/**
 * Replace the attributes. preg_replace_callback() callback.
 */
function _pathologic_replace($matches) {
  // Build the full URL, then take it apart
  global $base_url;
  if ($matches[9] === '?q=' || $matches[6] === 'index.php') {
    // This will be the case if the link tag was like:
    // <a href="?q=foo">
    $matches[10] = '?q=' . $matches[10];
  }
  $full = $base_url . '/' . $matches[10];
  // …then take it apart
  $parts = parse_url($full);
  // Trim initial slash off path. Note that substr() will return FALSE here if
  // the path is just one character (just '/'), but url() seems to be okay with
  // that.
  $parts['path'] = substr($parts['path'], 1);

  // Need to parse the query parts
  if (isset($parts['query'])) {
    parse_str($parts['query'], $qparts);
    if (isset($qparts['q'])) {
      $parts['path'] = $qparts['q'];
      unset($qparts['q']);
    }
  }
  else {
    $qparts = array();
  }

  return $matches[1] . '="' . url($parts['path'], array('query' => $qparts, 'fragment' => isset($parts['fragment']) ? $parts['fragment'] : NULL, 'absolute' => TRUE));
}